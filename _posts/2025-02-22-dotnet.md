---
layout: post
title: .NET Reviewer
author: joey
tags: [dotnet, reviewer]
---

Ace your .NET systems and coding interviews with this structured refresher covering runtime fundamentals, language features, data access choices, and architecture conversations.

## How To Use This Sheet
- Skim the **Runtime & Execution** matrix before technical screens to keep the platform layers straight.
- Use the **Scenario Playbooks** when answering architecture or “what would you choose” prompts.
- Drill on the **Rapid-Fire Q&A** set right before walking into the room to sharpen terminology.

## Runtime & Execution Stack

| Topic | What To Remember | Interview Angle |
| --- | --- | --- |
| Common Language Infrastructure (CLI) | Language-neutral specification for metadata, IL, and execution | Explain how multiple languages (.cs, .vb, F#) run on the same runtime |
| Common Language Runtime (CLR) | Manages IL execution, JIT compilation, GC, security, threading | Contrast CLR with JVM; talk about GC generations and managed code |
| Managed vs. Unmanaged | Managed runs under CLR supervision; unmanaged is native (C/C++) | Describe P/Invoke and when unsafe code is warranted |
| Assemblies & IL | Assemblies bundle IL + metadata, modules, manifests | Mention why IL enables cross-language tooling |

## Language Mechanics Cheat Sheet
- **Generics**: Compile-time type safety without boxing; mention `List<T>` vs. `ArrayList`.
- **Extension Methods**: Static methods that extend types; great for fluent APIs.
- **Delegates & Events**: Type-safe function pointers; foundation for LINQ, events, middleware.
- **Keywords trio**: `virtual` for override hooks, `sealed` to prevent inheritance, `abstract` to force contract fulfillment.
- **`const` vs. `readonly`**: compile-time literal vs. runtime immutable set in constructor/static ctor.

### Extension Method Skeleton
```csharp
public static class StringExtensions
{
    public static bool IsNullOrWhitespace(this string input)
    {
        return string.IsNullOrWhiteSpace(input);
    }
}
```

## Type System & Object Orientation

| Concept | Quick Reminder | Interview Hook |
| --- | --- | --- |
| Class vs. Struct | Class = reference, heap, supports inheritance. Struct = value, stack, no inheritance | When to prefer structs (immutable, small value types) |
| Interfaces vs. Abstract Classes | Interfaces = contract only; abstract classes can hold shared implementation | Talk about versioning and default interface methods |
| Inheritance & Polymorphism | Base/derived relationships, override vs. overload | Explain LSP by swapping derived implementations |
| Boxing & Unboxing | Value → object (boxing) vs. object → value (unboxing) | Performance considerations in tight loops |

## Async & Concurrency Playbook
- **Tasks vs. Threads**: Task is a higher-level abstraction that can multiplex threads via the thread pool.
- **`async`/`await`**: Compile-time state machine, frees the thread during awaits. Mention ConfigureAwait in library code.
- **`Task.Run`**: Use for CPU-bound work, not to wrap naturally async I/O.
- **Cancellation & timeouts**: Always surface `CancellationToken` in library APIs and respect cooperative cancellation.

### Sample Async Flow
```csharp
public async Task<int> FetchTotalAsync(IHttpClientFactory clientFactory, CancellationToken token)
{
    using var client = clientFactory.CreateClient("orders");
    using var response = await client.GetAsync("/totals", token);
    response.EnsureSuccessStatusCode();
    return int.Parse(await response.Content.ReadAsStringAsync(token));
}
```

## Data Access Strategy Ladder

| Option | When To Use | Trade-offs |
| --- | --- | --- |
| ADO.NET | Full control, performance-tuned queries, legacy codebases | Boilerplate, manual mapping |
| LINQ to Objects/Entities | Declarative query syntax, strong typing | Watch for deferred execution and N+1 queries |
| Entity Framework Core | Rapid CRUD, migrations, change tracking | Must profile generated SQL, consider compiled queries |
| Dapper / Micro-ORM | Balanced control + convenience | Manual SQL maintenance |

## Middleware, DTOs, and API Patterns
- ASP.NET Core middleware pipeline executes in order; emphasize short-circuit patterns and `Use`, `Map`, `Run`.
- **DTO vs. POCO**: DTOs flatten transport concerns (versioning, serialization). POCOs hold domain behavior. Use AutoMapper or manual mapping for clarity.
- Discuss versioning strategies (URL vs. header) and cross-cutting concerns (logging, correlation IDs).

## Dependency Management & Architecture
- **Dependency Injection (DI)**: Constructor injection + IoC containers (`AddSingleton`, `AddScoped`, `AddTransient`). Highlight testability.
- **SOLID & Clean Architecture**: Entities/domain core, application services, infrastructure adaptability. Mention boundaries via interfaces/mediators.
- **Middleware vs. Filters**: Filters for MVC pipeline, middleware for cross-cutting HTTP concerns.

### Minimal DI Example
```csharp
services.AddScoped<IInvoiceService, InvoiceService>();

public class InvoiceController
{
    private readonly IInvoiceService _svc;
    public InvoiceController(IInvoiceService svc) => _svc = svc;
}
```

## Security & Identity Highlights
- Authentication (who are you?) vs. Authorization (what can you do?).
- Use ASP.NET Core Identity or external IdP (Azure AD, Auth0) with OpenID Connect.
- Leverage policy-based authorization and `IAuthorizationHandler` for custom rules.
- Secure secrets with Azure Key Vault or user secrets in dev; avoid storing secrets in config.

## Testing & Quality
- Unit testing frameworks: xUnit (favorite for ASP.NET Core templates), NUnit, MSTest.
- Mocking libraries: Moq, NSubstitute; emphasize dependency boundaries.
- BDD/TDD interplay: write failing test, implement minimal code, refactor. Mention SpecFlow for .NET.
- Integration tests: `WebApplicationFactory` for ASP.NET Core end-to-end pipeline.

## Scenario Playbooks
1. **Design a multi-tenant SaaS API**: Discuss ASP.NET Core, API versioning, EF Core with row-level filters, caching via Redis, distributed tracing.
2. **Legacy migration**: Move from .NET Framework to .NET 8 → start with analyzing API surface, adopt Windows Compatibility Pack, plan containerization.
3. **High-frequency trading or IoT ingestion**: Use Channels, Span<T>, value types to reduce allocations, configure server GC.
4. **Desktop + Web hybrid**: Share business logic via .NET Standard/.NET 8 class library, use MAUI or WPF + gRPC/REST backend.

## Rapid-Fire Q&A
- **Task vs. ValueTask?** ValueTask avoids allocations for synchronous completions but adds complexity; use sparingly.
- **`IEnumerable` vs. `IQueryable`?** `IEnumerable` executes in-memory; `IQueryable` composes provider-specific queries (EF Core translates to SQL).
- **`yield return` advantage?** Generates lazy iterators, streaming large sequences without buffering.
- **When to mark class `sealed`?** Prevent inheritance when you rely on invariants or want JIT optimizations.
- **`IDisposable` pattern?** Implement for managing unmanaged resources; pair with `using`/`await using` and finalizer safeguards.

## Whiteboard / Code Exercises
- Sketch an ASP.NET Core request pipeline with middleware ordering and cross-cutting concerns.
- Implement a simplified repository pattern with EF Core and discuss pros/cons vs. direct DbContext usage.
- Write a thread-safe caching layer using `IMemoryCache` and background refresh.
- Model a plug-in system using reflection and dependency injection.

## Study Tips
- Review the .NET architecture docs and performance guidance on docs.microsoft.com.
- Practice LeetCode-style problems in C# to stay fluent with language features (pattern matching, records, spans).
- Keep a cheatsheet of common `dotnet` CLI commands (`dotnet new`, `dotnet test`, `dotnet publish`).
- Stay current with .NET release notes—interviewers love to ask about the latest runtime improvements.
