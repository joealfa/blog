---
layout: post
title: SQL Reviewer
author: joey
tags: [sql, reviewer]
---

Turn SQL interviews into a strength with practical query templates, performance tuning heuristics, and scenario walkthroughs.

## How To Use This Sheet
- Review the **Query Pattern Toolkit** before coding challenges to recall ranking/window strategies.
- Reference the **Indexing Decisions** matrix when interviewers ask about optimization.
- Use the **Scenario Playbooks** to structure answers for system design and analytics prompts.

## Query Pattern Toolkit

| Goal | Technique | Sample Snippet |
| --- | --- | --- |
| Second Highest Value | Window functions (`DENSE_RANK`) to handle ties | `SELECT amount FROM (SELECT amount, DENSE_RANK() OVER (ORDER BY amount DESC) AS rnk FROM payments) T WHERE rnk = 2;` |
| Top-N per Group | `ROW_NUMBER()` partitioned by group | `ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY order_date DESC)` |
| Running Total | `SUM()` window with `ROWS BETWEEN` | `SUM(total) OVER (PARTITION BY account_id ORDER BY txn_date ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)` |
| Gap Detection | Use `LAG`/`LEAD` for deltas | `WHERE txn_amount - LAG(txn_amount) OVER (...) > 1000` |
| Conditional Aggregates | `SUM(CASE WHEN ... THEN 1 ELSE 0 END)` | `SUM(CASE WHEN status='FAILED' THEN 1 ELSE 0 END)` |

## Join Reference Card

| Join | What You Get | Common Use |
| --- | --- | --- |
| INNER | Intersections only | Matching customers/orders |
| LEFT OUTER | All from left + matches | Show all users, even without orders |
| RIGHT OUTER | Mirror of left | Legacy data models (use sparingly) |
| FULL OUTER | Union of both sides with NULLs | Data reconciliation/migration checks |
| CROSS | Cartesian product | Test data generation, dimension combinations |
| SELF | Table joined to itself | Hierarchies, org charts |

**Tip**: Always explain NULL-handling strategy and referential integrity assumptions when describing join logic.

## Indexing Decisions Matrix

| Index Type | Use When | Interview Talking Point |
| --- | --- | --- |
| Clustered (Primary) | Table needs physical ordering; only one per table | Impacts range scans and clustering key choice |
| Non-Clustered | Frequent WHERE/ORDER BY lookups | Covering indexes, INCLUDE columns, seek vs. scan |
| Unique | Enforce data integrity | Guarantees no duplicates (email, username) |
| Composite | Multi-column filters | Column order matters; left-most prefix rule |
| Full-Text | Search across free-form text | Language-specific tokenization, ranking |

**Trade-offs**: Faster reads vs. slower writes, extra storage, maintenance windows for rebuild/reorganize.

## Optimization Checklist
- Inspect execution plans (actual vs. estimated) for scans, lookups, hotspots.
- Parameterize queries to leverage plan cache; avoid implicit conversions.
- Use batching/pagination for large result sets (`LIMIT/OFFSET`, keyset pagination).
- Normalize up to the point of diminishing returns; denormalize carefully for read-heavy workloads.
- Profile database metrics: buffer cache hit ratio, lock waits, deadlocks.

## Transaction & Concurrency Basics
- **ACID**: Atomicity, Consistency, Isolation, Durability—anchor your explanations here.
- Isolation levels: Read Uncommitted → Serializable; discuss phantom reads, snapshot isolation.
- Locking vs. MVCC: Understand how PostgreSQL, SQL Server, MySQL InnoDB handle concurrency.
- Use optimistic concurrency with row versions or timestamps when conflicts are rare.

## Data Modeling & Architecture Highlights
- **Normalization**: 1NF → 3NF to reduce redundancy; mention Boyce-Codd for strict scenarios.
- **Denormalization**: Use for analytics, caching, reporting; manage consistency through ETL or triggers.
- **Star vs. Snowflake** schemas for BI; discuss fact tables, slowly changing dimensions.
- **Partitioning**: Range/hash/list to handle massive tables; explain pruning and partition elimination.

## Scenario Playbooks
1. **Design analytics for a marketplace**: Fact tables for orders, dimensions for users/products/time; incremental ETL; aggregate tables for dashboards.
2. **High-write, high-read API**: Consider read replicas, caching layer (Redis), queue for heavy reporting workloads, idempotent write design.
3. **Audit logging**: Append-only tables, CDC streams (Debezium, logical replication), hashing for tamper detection.
4. **Multi-tenant database strategy**: Database-per-tenant vs. shared with tenant_id column; address security, noisy neighbor mitigation.

## Rapid-Fire Q&A
- **Difference between `WHERE` vs. `HAVING`?** `WHERE` filters rows before grouping; `HAVING` filters after aggregation.
- **Explain `EXPLAIN`.** Shows query plan; look at join algorithms (nested loop, hash, merge), index usage.
- **When to choose `UNION` vs. `UNION ALL`?** `UNION` removes duplicates; `UNION ALL` keeps them (faster).
- **What is a covering index?** Includes all columns needed by query, eliminating lookups.
- **Why use `COALESCE`?** Normalize NULL handling, avoid unexpected NULL propagation in calculations.

## Whiteboard / SQL Pairing Drills
- Write a query to find top 3 products per category with total revenue; discuss tie handling.
- Design schema for a task management app supporting subtasks and audit trail.
- Translate a business request into a window function query and explain the plan.
- Refactor an inefficient query using CTEs, indexes, and set-based operations.

## Study Tips
- Practice with real interview-style SQL challenges (StrataScratch, LeetCode Database, Mode Analytics SQL School).
- Capture before/after execution plans during personal projects to build intuition.
- Memorize common window function patterns; they show up frequently.
- Read the documentation for your preferred RDBMS on locking and indexing—nuances impress interviewers.
