---
layout: post
title: Software Engineer Reviewer
author: joey
tags: [software, engineer, reviewer]
---

Bring a product-minded perspective to generalist software engineering interviews: architecture, design patterns, delivery practices, and systems thinking are all in one place here.

## How To Use This Sheet
- Commit the **Core Principles Matrix** to memory for behavioral and system design prompts.
- Reach for the **Delivery Playbook** bullets when asked about engineering process or collaboration.
- Use the **Whiteboard Drills** to rehearse concise narratives with diagrams and trade-off discussions.

## Core Principles Matrix

| Theme | What To Emphasize | Interview Usage |
| --- | --- | --- |
| SOLID | SRP, OCP, LSP, ISP, DIP. Focus on reducing coupling and improving cohesion. | Tie to refactoring, microservices, or feature isolation stories. |
| Clean Architecture | Domain/application/infrastructure boundaries, dependency rule, ports & adapters. | Explain how you kept frameworks at the edges and business rules at the center. |
| Event-Driven Thinking | Producers, consumers, eventual consistency, idempotency. | Discuss asynchronous processing, retry policies, and observability needs. |
| Microservices | Bounded contexts, API contracts, service discovery, saga patterns. | Highlight deployment autonomy and how you handled cross-service transactions. |

## SOLID Principles Deep Dive

**Single Responsibility Principle (SRP)**
- A class should have only one reason to change—one responsibility, done well.
- Promotes modularity and easier testing by isolating concerns.
- **Interview tip:** Discuss refactoring large controllers or services into focused units.

**Open-Closed Principle (OCP)**
- Software entities should be open for extension but closed for modification.
- Add new functionality without changing existing code through abstraction and polymorphism.
- **Interview tip:** Explain how you used strategy patterns or plugin architectures.

**Liskov Substitution Principle (LSP)**
- Derived classes must be substitutable for their base classes without breaking behavior.
- If class A is a subtype of class B, you should swap B with A seamlessly.
- **Interview tip:** Relate to contract design and ensuring derived types honor base expectations.

**Interface Segregation Principle (ISP)**
- No client should be forced to depend on methods it doesn't use.
- Create smaller, focused interfaces instead of large, monolithic ones.
- **Interview tip:** Show how you split fat interfaces into role-specific contracts.

**Dependency Inversion Principle (DIP)**
- High-level modules should not depend on low-level modules; both depend on abstractions.
- Abstractions should not depend on details; details depend on abstractions.
- **Interview tip:** Highlight dependency injection and how it enabled testing and swapping implementations.

## Design Patterns Cheat Sheet

| Category | Patterns To Know | Highlight |
| --- | --- | --- |
| Creational | Factory, Abstract Factory, Builder, Singleton, Prototype | Use to explain how you isolate object construction and support testing. |
| Structural | Adapter, Facade, Decorator, Composite, Proxy, Bridge, Flyweight | Tie to legacy integrations, feature toggles, or UI composition. |
| Behavioral | Strategy, Observer, Command, Chain of Responsibility, Mediator, Visitor, State | Illustrate how they simplify complex control flow and variation points. |

**Pattern Benefits Recap**
- Shared vocabulary for the team.
- Faster solutioning for recurring problems.
- Separation of concerns with extensibility hooks.

### Creational Patterns
- **Factory Method**: Separate object construction from implementation; produce objects without specifying exact class.
- **Abstract Factory**: Super-factory creating other factories; layer of abstraction over Factory.
- **Singleton**: Ensures a class has one instance with global access point.
- **Prototype**: Clone existing objects instead of creating from scratch; hides complexity of instantiation.
- **Builder**: Construct complex objects step-by-step; same construction process, different representations.

### Structural Patterns
- **Adapter**: Convert interface of a class into another interface clients expect; enable incompatible interfaces to work together.
- **Bridge**: Decouple abstraction from implementation; develop independently.
- **Composite**: Compose objects into tree structures for part-whole hierarchies; treat groups like individual instances.
- **Decorator**: Dynamically add functionality to objects without affecting other instances.
- **Facade**: Unified interface to a set of interfaces in a subsystem; high-level interface for easier use.
- **Flyweight**: Decrease object count for efficiency; share similar objects.
- **Proxy**: Stand-in or placeholder for another object; control access or add functionality.

### Behavioral Patterns
- **Chain of Responsibility**: Pass requests along a chain of handlers until one handles it.
- **Command**: Encapsulate request as object; parameterize and queue requests.
- **Iterator**: Traverse a collection without exposing underlying structure.
- **Mediator**: Central object managing communication; reduce dependencies between objects.
- **Memento**: Capture and restore object state.
- **Observer**: Notify dependent objects (observers) when subject changes.
- **State**: Change object behavior when internal state changes.
- **Strategy**: Encapsulate algorithms; make them interchangeable.
- **Template Method**: Define algorithm skeleton in base class; subclasses override specific steps.
- **Visitor**: Add new operations to existing structures without modification.

## Delivery & Collaboration Playbook
- **TDD & BDD**: Write tests first (`Red → Green → Refactor`), layer behavior specs with Gherkin or SpecFlow/Cucumber for business-readable coverage.
- **Code Reviews**: Focus on correctness, maintainability, risk. Use checklists and automation (CI, static analysis) to keep reviewers focused.
- **Continuous Delivery**: Automate build, test, and deployment; feature flags to decouple deployment from release.
- **Observability**: Metrics, tracing, structured logs; use them in incident post-mortems.

## Dependency Injection & IoC
Dependency injection separates constructing objects from using them, leading to loosely coupled programs. Instead of a class creating its dependencies, an external "injector" provides them.

**Key Benefits:**
- Classes are independent from dependency creation.
- Applications support different configurations easily.
- Improved testability through mock/stub injection.

**Interview Angle:** Discuss how DI enabled unit testing, swapped implementations, or facilitated multi-environment deployment.

## API & Web Fundamentals

| Topic | Quick Hits | Interview Hook |
| --- | --- | --- |
| HTTP Verbs | GET, POST, PUT, PATCH, DELETE, HEAD, OPTIONS, TRACE, CONNECT | Map verbs to idempotency and safe operations. |
| REST Constraints | Statelessness, cacheable responses, uniform interface, layered system | Narrate how you built evolvable APIs with HATEOAS or versioning strategies. |
| CRUD & CQRS | CRUD is baseline; CQRS splits read/write models for scaling & complexity management | Link to event sourcing or read-optimized projections. |
| CORS | Browser security model for cross-origin requests | Mention preflight requests and security implications. |

### HTTP Methods Quick Reference
- **GET**: Retrieve resource (idempotent, safe)
- **POST**: Create resource (not idempotent)
- **PUT**: Replace resource (idempotent)
- **PATCH**: Partial update (not necessarily idempotent)
- **DELETE**: Remove resource (idempotent)
- **HEAD**: Like GET but headers only
- **OPTIONS**: Supported methods for resource
- **TRACE**: Debug echo
- **CONNECT**: Tunnel establishment (HTTPS)

## Object-Oriented Programming Pillars

### 1. Encapsulation
- Restrict access to object components; protect internal state.
- Use access modifiers (private, protected, public).
- **Interview tip:** Explain how encapsulation enabled you to refactor internals without breaking clients.

### 2. Inheritance
- New class inherits properties/methods from existing class (parent/base → child/derived).
- **Interview tip:** Discuss when composition over inheritance is preferred.

### 3. Polymorphism
- Objects treated as instances of parent class; parent reference to child object.
- **Interview tip:** Show method overriding examples and runtime binding.

### 4. Abstraction
- Hide complex implementation; show only essential features.
- Use abstract classes or interfaces.
- **Interview tip:** Relate to designing stable APIs with hidden implementation details.

## Architecture Deep Dives
- **Clean Architecture Narrative**: Walk through presentation → application → domain → infrastructure layers. Emphasize that dependencies point inward.
- **Microservices vs. Monolith**: Start monolith for speed, extract services around clear bounded contexts once scaling pain justifies it.
- **Caching Strategy**: Multi-tier (client, CDN, edge, server); mention cache invalidation, TTL, and "stale-while-revalidate."
- **Event-Driven Architecture**: Use message brokers (Kafka, RabbitMQ, Service Bus) for resilience; design idempotent consumers and dead-letter handling.
- **Security Fundamentals**: Defense in depth, least privilege, token-based auth (OAuth2/OIDC), encryption in transit and at rest.

## Browser Request Walkthrough
1. **Resolve**: DNS lookup (local cache → hosts file → recursive resolver → authoritative server).
2. **Connect**: TCP three-way handshake, TLS handshake for HTTPS.
3. **Request**: Browser sends HTTP request with headers, cookies, payload.
4. **Process**: Server authenticates, authorizes, hits application logic, database, cache.
5. **Respond**: Server returns status code, headers, body; CDN may cache response.
6. **Render**: Browser parses HTML → DOM, CSS → CSSOM, JS execution, layout, paint.
7. **Interact**: Subsequent AJAX/fetch/WebSocket calls driven by user input.

## System Design Scenario Prompts
1. **Design a feature flag service**: Cover rollout strategies, SDKs, targeting rules, persistence, audit trails.
2. **Build a multi-region ecommerce platform**: Choose CDN, database replication strategy, payment gateway integration, resilience tactics.
3. **Implement real-time collaboration**: WebSockets/SignalR, optimistic concurrency (OT/CRDT), conflict resolution, presence service.
4. **Migrate monolith to microservices**: Strangle pattern, anti-corruption layer, transactional outbox for reliable events.

## Rapid-Fire Q&A
- **Difference between SLA, SLO, SLI?** Agreement vs. objective vs. measurement.
- **CAP Theorem takeaway?** You can choose availability or consistency under partition; design based on business tolerance.
- **What is backpressure?** Mechanism to signal producers to slow down when consumers can't keep up.
- **Explain eventual consistency to a PM.** Data is temporarily out of sync but converges; you design UX and compensation flows accordingly.
- **Why prefer idempotent APIs?** Makes retries safe, critical for distributed systems.
- **BDD vs. TDD?** BDD extends TDD; focuses on behavior and stakeholder-readable specs. TDD focuses on test-first development cycle.

## Whiteboard Drills
- Draw a Clean Architecture diagram and place sample components (controllers, use cases, repositories).
- Sketch the lifecycle of a browser request including CDN, load balancer, app tier, database.
- Model an event-driven order pipeline with saga orchestration and compensating actions.
- Map out a monitoring stack: logs, metrics, traces, alerting thresholds, on-call escalation.

## Study Tips
- Maintain a personal repository of architecture diagrams you can reuse in interviews.
- Summarize post-incident reviews to practice storytelling: problem, impact, response, lessons.
- Read the latest Accelerate/DORA metrics research for leadership conversations.
- Rehearse STAR-format answers for leadership principles and cross-functional collaboration stories.
