---
layout: post
title: React Reviewer
author: joey
tags: [react, reviewer]
---

Elevate your React interviews with a quick-hit guide covering rendering, hooks, state management, and production-grade patterns.

## How To Use This Sheet
- Revisit the **Rendering Foundations** section before whiteboard questions about reconciliation or performance.
- Lean on the **Hooks & State Patterns** grids when choosing the right tool during scenario prompts.
- Scan the **Rapid-Fire Q&A** moments ahead of short-format technical screenings.

## Rendering Foundations

| Topic | Key Details | Interview Angle |
| --- | --- | --- |
| Virtual DOM & Reconciliation | React diffs trees, applies minimal DOM mutations; keys drive stable identity. | Explain why keys matter, how React batches state updates. |
| Component Types | Function components with hooks are the default; class components still appear in legacy code. | Discuss refactoring strategies and hook migrations. |
| One-way Data Flow | Props down, events up; makes debugging and memoization predictable. | Relate to large app state management and testing story. |
| Controlled vs. Uncontrolled | Controlled uses React state; uncontrolled uses refs/DOM state. | Talk about forms, performance, and libraries like React Hook Form. |

## Hooks & State Patterns

| Hook | Use For | Watch Out For |
| --- | --- | --- |
| `useState` | Local UI state, primitives & simple objects | State updates are async; avoid stale closures with functional updates. |
| `useReducer` | Complex state transitions, state machines, shared logic | Ensure reducer is pure; memoize dispatch context. |
| `useEffect` | Side effects (network, subscriptions); sync DOM after render | Dependencies array correctness, cleanup functions, avoiding double fetches in Strict Mode. |
| `useMemo` / `useCallback` | Performance optimizations; stable references | Only memoize when needed; understand dependency arrays. |
| `useRef` | Access DOM nodes, mutable containers, caching values between renders | Remember changes don’t trigger re-render; useful for integration with third-party libs. |

### Custom Hook Skeleton
```javascript
import { useEffect, useState } from 'react';

export function useFetch(url, options) {
  const [state, setState] = useState({ data: null, loading: true, error: null });

  useEffect(() => {
    let cancelled = false;

    async function load() {
      try {
        const res = await fetch(url, options);
        if (!res.ok) throw new Error(res.statusText);
        const json = await res.json();
        if (!cancelled) setState({ data: json, loading: false, error: null });
      } catch (error) {
        if (!cancelled) setState({ data: null, loading: false, error });
      }
    }

    load();
    return () => { cancelled = true; };
  }, [url, options]);

  return state;
}
```

## State Management & Data Strategies
- **Local State First**: Start with component state; lift state only when multiple siblings need it.
- **Context API**: Use for global settings (theme, auth) but avoid overusing; pair with memoized providers.
- **Redux / Zustand / MobX**: Centralize complex state; emphasize predictable updates, dev tools, and reselect/memoization.
- **Server State**: Reach for React Query/Apollo SWR to manage caching, background refetches, and synchronization with the server.

## Component Composition Patterns
- **Container vs. Presentational**: Encapsulate data fetching in containers; keep UI components pure and reusable.
- **Render Props**: Share cross-cutting concerns like mouse position, authentication gating.
- **Higher-Order Components**: Useful for legacy code; understand pitfalls (wrapper hell, ref forwarding).
- **Compound Components**: Build flexible APIs (like `<Tabs>` with `<Tabs.List>`). Works well with context.

## Routing & Navigation
- React Router v6: `createBrowserRouter`, nested routes, loader/actions.
- Patterns: route-based code splitting with `React.lazy`, route guards (wrapping protected routes), data prefetch with loaders.
- Global error boundaries and pending UI (Suspense) make for robust UX.

## Performance Tuning Checklist
- Enable concurrent features (React 18) for transitions and Suspense.
- Memoize expensive components (`React.memo`) and selectors.
- Defer non-critical rendering with `useDeferredValue` and `useTransition`.
- Use the React Profiler to identify wasted renders; analyze dependency arrays.

## Testing Strategy
- **Unit tests** with React Testing Library (focus on user interactions, not internal implementation).
- **Integration tests** for flows across components (form submission, navigation).
- **E2E tests** via Cypress/Playwright for critical journeys.
- Mock network with MSW; keep tests resilient by querying DOM by role/label text.

## Scenario Playbooks
1. **Design a data-intensive dashboard**: Discuss virtualization (`react-window`), Suspense for async data, caching strategy, skeleton loading.
2. **Build an accessible form system**: Controlled components, validation libraries, ARIA attributes, screen reader testing.
3. **Real-time collaboration UI**: WebSockets/EventSource, optimistic updates, conflict resolution, throttled state updates.
4. **Micro-frontend integration**: Module federation, shared dependencies, routing coordination, consistent design tokens.

## Rapid-Fire Q&A
- **Why keys in lists?** Stable identity for diffing; use persistent IDs, not array index.
- **Difference between `useLayoutEffect` and `useEffect`?** `useLayoutEffect` runs synchronously after DOM mutations; use for measurements, be wary of blocking paint.
- **How does Suspense work?** Components throw promises; React pauses rendering and shows fallback until resolved.
- **When to use `useImperativeHandle`?** Expose imperative methods when wrapping uncontrolled components.
- **Explain hydration.** Server renders markup, client attaches event listeners; mismatches cause warnings.

## Whiteboard / Pairing Drills
- Sketch component hierarchy for a product detail page; identify where state lives.
- Implement a debounced search input using hooks and discuss accessibility.
- Refactor a class component with lifecycle hooks into a function component using hooks.
- Design an error boundary and explain how it isolates rendering failures.

## Study Tips
- Build a small project with React 18 features (Suspense for data fetching, transitions) to speak from experience.
- Follow the React docs beta site for the latest guidance and canonical patterns.
- Practice explaining React patterns to a non-React engineer—clarity matters in interviews.
- Keep notes on trade-offs between state libraries so you can tailor answers to the interviewer’s stack.
